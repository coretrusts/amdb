# AmDb 数据库组件关联关系分析

## 组件概述

AmDb 数据库由以下组件构成：

1. **database.amdb** - 数据库元数据文件（版本、描述、统计信息）
2. **wal/** - 预写日志（Write-Ahead Log）
3. **versions/** - 版本管理器数据（版本历史）
4. **shards/** - 分片存储（如果启用分片）
5. **merkle/** - Merkle树数据（数据完整性验证）
6. **lsm/** - LSM树数据（主要存储引擎）
7. **indexes/** - 索引管理器数据（主键、版本、时间索引）
8. **bplus/** - B+树数据（快速读取缓存）
9. **audit_logs/** - 审计日志（如果启用）

## 组件关联关系

### 1. 写入操作流程（put/delete）

```
用户调用 put(key, value)
    ↓
1. version_manager.create_version()  ← 创建版本对象（内存）
    ↓
2. storage.put()  ← 写入存储引擎
   ├─ lsm_tree.put()  ← 写入LSM树（主要存储）
   ├─ bplus_tree.insert()  ← 异步更新B+树（快速读取）
   └─ merkle_tree.put()  ← 更新Merkle树（完整性验证）
    ↓
3. index_manager.put()  ← 更新索引（内存）
   ├─ primary_index[key] = (value, version)
   ├─ version_index[key].append((version, timestamp))
   └─ time_index.append((timestamp, key))
    ↓
4. wal_logger.log_put()  ← 异步写入WAL（持久性保证）
    ↓
5. audit_logger.log_put()  ← 异步记录审计日志（可选）
```

### 2. 读取操作流程（get）

```
用户调用 get(key)
    ↓
1. _check_and_reload_if_updated()  ← 检查文件是否更新
    ↓
2. version_manager.get_latest()  ← 优先从版本管理器获取（内存）
    ↓ (如果失败)
3. storage.get()  ← 从存储引擎获取
   ├─ bplus_tree.get()  ← 优先从B+树读取（如果已同步）
   └─ lsm_tree.get()  ← 从LSM树读取（主要数据源）
```

### 3. 持久化流程（flush）

```
用户调用 flush()
    ↓
1. storage.lsm_tree.flush()  ← 同步刷新LSM树MemTable到磁盘
    ↓
2. 同步模式（force_sync=True）：
   ├─ storage.bplus_tree.flush()  ← 持久化B+树
   ├─ storage.merkle_tree.save_to_disk()  ← 持久化Merkle树
   ├─ version_manager.save_to_disk()  ← 持久化版本数据
   ├─ index_manager.save_to_disk()  ← 持久化索引数据
   └─ _save_metadata()  ← 保存元数据
    ↓
3. 异步模式（async_mode=True）：
   └─ 后台线程异步持久化非关键文件
```

## 组件依赖关系

### 强关联组件（必须同步）

1. **version_manager ↔ storage (lsm_tree)**
   - 版本管理器记录版本号，存储引擎使用版本号存储数据
   - **必须同步**：版本号和存储数据必须一致

2. **index_manager ↔ version_manager**
   - 索引管理器使用版本号和时间戳建立索引
   - **必须同步**：索引必须反映版本管理器的状态

3. **storage (merkle_tree) ↔ storage (lsm_tree)**
   - Merkle树用于验证LSM树的数据完整性
   - **必须同步**：Merkle根哈希必须与LSM树数据一致

### 弱关联组件（写入可以异步，但文件必须存在）

1. **wal ↔ storage**
   - WAL用于恢复数据，但数据已存储在LSM树中
   - **写入可以异步**：WAL写入失败不影响主操作
   - **⚠️ 但文件必须存在**：缺少WAL文件会导致无法恢复

2. **bplus_tree ↔ lsm_tree**
   - B+树是LSM树的缓存，用于快速读取
   - **更新可以异步**：B+树更新失败不影响数据写入
   - **⚠️ 但文件应该存在**：缺少B+树文件会导致读取性能下降

3. **audit_logs ↔ 所有组件**
   - 审计日志仅用于审计，不影响数据操作
   - **写入可以异步**：审计日志写入失败不影响主操作
   - **✅ 可以不存在**：缺少审计日志不影响核心功能

4. **database.amdb ↔ 所有组件**
   - 元数据文件包含统计信息，但不影响数据操作
   - **更新可以异步**：元数据更新失败不影响数据操作
   - **⚠️ 但文件应该存在**：缺少元数据文件会导致无法识别数据库

## 索引更新正确性保证

### 1. 主键索引（primary_index）

**更新时机**：
- 每次 `put()` 或 `delete()` 操作时立即更新
- 在 `index_manager.put()` 中同步更新

**正确性保证**：
- ✅ 使用锁（`self.lock`）保证线程安全
- ✅ 与 `version_manager` 同步更新
- ✅ 在内存中维护，flush时持久化

### 2. 版本索引（version_index）

**更新时机**：
- 每次创建新版本时更新
- 使用二分查找保持有序

**正确性保证**：
- ✅ 使用锁保证线程安全
- ✅ 与 `version_manager` 的版本号一致
- ✅ 保持有序，支持范围查询

### 3. 时间索引（time_index）

**更新时机**：
- 每次 `put()` 或 `delete()` 操作时更新
- 使用二分查找保持有序

**正确性保证**：
- ✅ 使用锁保证线程安全
- ✅ 与 `version_manager` 的时间戳一致
- ✅ 保持有序，支持时间点查询

### 4. 二级索引（secondary_indexes）

**更新时机**：
- 需要手动调用 `update_secondary_index()`
- 不会自动更新

**正确性保证**：
- ⚠️ 需要应用层手动维护
- ⚠️ 如果忘记更新，可能导致查询不准确

## 数据一致性保证

### 1. 写入一致性

**保证机制**：
- ✅ 使用锁（`self.lock`）保证原子性
- ✅ 版本管理器、存储引擎、索引管理器同步更新
- ✅ WAL日志保证持久性（即使崩溃也能恢复）

**潜在问题**：
- ⚠️ B+树更新是异步的，可能短暂不一致（但不影响读取，因为会回退到LSM树）
- ⚠️ 审计日志是异步的，可能丢失（但不影响数据操作）

### 2. 读取一致性

**保证机制**：
- ✅ 优先从版本管理器读取（内存，最新）
- ✅ 如果失败，从存储引擎读取（LSM树或B+树）
- ✅ 自动检测文件更新，重新加载数据

**潜在问题**：
- ⚠️ 如果B+树未同步，可能读取到旧数据（但会回退到LSM树）
- ⚠️ 如果索引未持久化，重启后需要重新构建

### 3. 持久化一致性

**保证机制**：
- ✅ LSM树MemTable同步刷新（关键数据）
- ✅ 版本管理器、索引管理器同步持久化（同步模式）
- ✅ WAL日志保证数据不丢失

**潜在问题**：
- ⚠️ 异步模式下，非关键文件可能未及时持久化
- ⚠️ 如果flush失败，部分数据可能未持久化

## 组件完整性分析

### ⚠️ 重要：数据库文件是一个整体

**所有数据库文件都是关联的，缺少任何关键文件都会导致：**
- 数据不一致
- 无法正确读取数据
- 索引错误
- 数据完整性验证失败
- 性能下降或功能异常

### 核心必需组件（缺少会导致数据库无法正常工作）

1. **versions/** - 版本管理器数据
   - **作用**：记录所有键的版本历史
   - **缺少后果**：无法追踪版本历史，可能导致数据不一致
   - **恢复**：可以从WAL恢复，但会丢失历史版本信息

2. **lsm/** - LSM树数据
   - **作用**：主要存储引擎，存储所有数据
   - **缺少后果**：无法读取数据，数据库无法使用
   - **恢复**：可以从WAL恢复，但需要完整恢复流程

3. **indexes/** - 索引数据
   - **作用**：主键索引、版本索引、时间索引
   - **缺少后果**：查询性能严重下降，可能无法正确查询
   - **恢复**：可以从versions和lsm重建，但重建过程耗时

4. **merkle/** - Merkle树数据
   - **作用**：数据完整性验证，计算Merkle根哈希
   - **缺少后果**：无法验证数据完整性，Merkle根哈希错误
   - **恢复**：可以从lsm重建，但重建过程耗时

5. **database.amdb** - 元数据文件
   - **作用**：数据库标识、统计信息、描述
   - **缺少后果**：无法识别数据库，无法获取统计信息
   - **恢复**：可以重新创建，但会丢失历史元数据

### 关键辅助组件（缺少会影响功能）

6. **wal/** - WAL日志
   - **作用**：预写日志，用于崩溃恢复
   - **缺少后果**：无法从崩溃中恢复，可能导致数据丢失
   - **恢复**：无法恢复，数据可能丢失

7. **bplus/** - B+树缓存
   - **作用**：快速读取缓存
   - **缺少后果**：读取性能下降，但可以从lsm读取
   - **恢复**：可以从lsm重建，但重建过程耗时

8. **shards/** - 分片数据（如果启用分片）
   - **作用**：分片存储数据
   - **缺少后果**：如果启用分片，缺少会导致数据丢失
   - **恢复**：无法恢复，数据丢失

### 可选组件（缺少不影响核心功能）

9. **audit_logs/** - 审计日志
   - **作用**：记录操作日志，用于审计
   - **缺少后果**：无法审计操作历史
   - **恢复**：无法恢复，审计历史丢失

## 建议和最佳实践

### 1. 索引更新

- ✅ **主键索引、版本索引、时间索引**：自动更新，无需担心
- ⚠️ **二级索引**：需要手动维护，确保与数据同步

### 2. 数据一致性

- ✅ **写入操作**：使用事务保证原子性
- ✅ **读取操作**：优先从版本管理器读取，确保最新数据
- ✅ **持久化**：定期调用 `flush()` 确保数据持久化
- ⚠️ **文件完整性**：所有数据库文件必须保持同步，缺少任何文件都会导致数据不一致

### 3. 组件维护

- ✅ **定期备份**：备份所有数据库文件（versions/、lsm/、indexes/、merkle/、wal/、database.amdb）
- ✅ **完整性检查**：定期检查所有文件是否存在且有效
- ✅ **定期清理**：清理旧的WAL日志和审计日志（但要保留最近的WAL用于恢复）
- ✅ **监控**：监控各组件的大小和性能

### 4. 故障恢复

- ⚠️ **文件缺失处理**：
  - 如果缺少 `versions/`：可以从WAL恢复，但会丢失历史版本
  - 如果缺少 `lsm/`：可以从WAL恢复，但需要完整恢复流程
  - 如果缺少 `indexes/`：可以从versions和lsm重建，但重建过程耗时
  - 如果缺少 `merkle/`：可以从lsm重建，但重建过程耗时
  - 如果缺少 `wal/`：无法恢复，数据可能丢失
- ✅ **数据验证**：使用Merkle树验证数据完整性
- ✅ **备份策略**：定期备份所有文件，确保可以完整恢复

## 总结

1. **组件关联**：
   - ⚠️ **所有数据库文件都是关联的整体**，缺少任何关键文件都会导致数据不一致或功能异常
   - 核心组件（version_manager、storage、index_manager、merkle）强关联，必须同步
   - 辅助组件（wal、bplus）虽然写入可以异步，但文件必须存在以保证完整性

2. **索引正确性**：
   - ✅ 主键索引、版本索引、时间索引自动更新，保证正确性
   - ⚠️ 二级索引需要手动维护
   - ⚠️ 如果索引文件缺失，虽然可以重建，但会导致查询性能下降和可能的数据不一致

3. **数据一致性**：
   - ✅ 写入时使用锁保证原子性
   - ✅ 读取时优先从版本管理器获取最新数据
   - ✅ 持久化时同步刷新关键数据
   - ⚠️ **所有文件必须保持同步**，缺少任何文件都会破坏数据一致性

4. **文件完整性**：
   - ⚠️ **核心文件（versions、lsm、indexes、merkle、database.amdb）必须存在**
   - ⚠️ **关键文件（wal、bplus）应该存在**，缺少会影响功能
   - ✅ 可选文件（audit_logs）可以不存在，不影响核心功能
   - ⚠️ **所有文件都是数据库的一部分，应该作为一个整体进行备份和恢复**

